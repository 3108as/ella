==========================
1 django-admin standardni tridy
==========================

Stranka zabyvajici se customizaci django-admin [http://docs.djangoproject.com/en/dev/ref/contrib/admin/] .
Vypichnu v nasledujicich sekcich par veci, ktere se nam mohou hodit.

Q: Vyresit podle uzivatelskych prav zobrazovani casti adminu (tlacitka pro pridani, mazani napr.)?

1.1 Admin obecne
================

1. Vice admin stranek (zakladni, advanced):
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#multiple-admin-sites-in-the-same-urlconf]

2. Dekorator kontrolujici administratorska prava prihlaseneho uzivatele v baliku:
   django.contrib.admin.utils.admin_perm_test

   Note:
   The admin_perm_test decorator can only be used on methods which are on ModelAdmins or AdminSites,
   you cannot use it on arbitrary functions.



1.2 Trida ModelAdmin
====================

1. Zaregistrovani vlastnich URL pro ModelAdmin tridu:
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#get-urls-self]

2. Vraceni policek pro cizi klic (Fields->Widget):
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#formfield-for-foreignkey-self-db-field-request-kwargs]

3. Vlastni validace Field prvku:
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#adding-custom-validation-to-the-admin]

4. Q'n'D zmena widgetu pro FieldType ve formulari:
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#formfield-overrides]

5. Sloupec 2x jako klic v modelu, jak rici modelAdmin tride, ktery si vybrat:
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#working-with-a-model-with-two-or-more-foreign-keys-to-the-same-parent-model]

6. list_display_links -- ktere sloupci v list zobrazeni objektu se daji pouzit jako odkazy vedouci na editacni stranku.
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#list-display-links]

7. Pocet polozek na stranku:
   [http://docs.djangoproject.com/en/dev/ref/contrib/admin/#list-per-page]


1.3 Trida AdminSite
===================

1. check_dependencies() metoda zjistuje vsechny potrebne veci pro chod adminovske stranky.
   Doporucuji v pripade potreby pretizit metodu a dodat vlastni kontroly pro nove veci,
   napr. existence nutnych uzivatelskych skupin atp.

2. root() metoda smeruje URL, rozklada je podle jmen aplikaci a modelu. Dale obsahuje vyjimky
   jako napr. URL pro zmenu hesla nebo redirect na nahledovou stranku (http://.../r/...)
   pouzije funkci z django.contrib.contenttypes.views shortcut .
   Pokud URL cast obsahuje aplikaci a model (oddelene / ) pouzije metodu self.model_page(),
   jinak pouzije self.app_index()

3. app_index() metoda generuje pohled na administrovatelne modely aplikace:
   - Prava pro zobrazeni zjistuji z vysledku metody objektu uzivatele user.has_module_perms(app_label)
   - Pokud ma uzivatel aspon jedno ze tri opravneni (add, del, change) kladne, zobrazi se
     administrovaci radek Modelu.
   - Zobrazeni uz resi django.contrib.admin.
   - na konec se Modely abecedne seradi.
   - titulek aplikace se v adminu lokalizuje jako _('%s administration') % app_label

4. index(request, extra_context=None)  metoda generuje data pro hlavni stranu adminu.


1.4 views/main.py (django.contrib.admin.views.main)
===================================================

Modul obsahuje class Changelist a par konstant. ChangeList = trida reprezentujici seznam objektu, ktere
se vypisi na strance odpovidajici zobrazeni jednoho konkretniho Modelu (napr. tabulka s clanky).

Konstanty, ktere se pouzivaji pro nastaveni nazvu HTTP parametru, napr.:
- SEARCH_VAR = 'q'
- PAGE_VAR = 'p'
- ORDER_VAR = 'o'
- ORDER_TYPE_VAR = 'ot'
- ...atd.

ChangeList instance ma property:
- model_admin = ModelAdmin
- model = Model
- lookup_opts = Model._meta.opts
- list_per_page
- search_fields
- list_filter
- list_display
- root_query_set = model_admin.queryset(request)

1. metoda get_results(request) -- v soucinnosti s Paginatorem naplni instancni promenne:
   - result_list: objekty na stranca
   - result_count (pocet na teto strance), full_result_count (celkovy pocet objektu)
   - can_show_all: ?
   - multi_page: True pokud vsechny vysledky lze zobrazit na > 1 strance, jinak False
   - paginator: objekt Paginator

2. metoda get_filters(request) -- vraci list instanci FilterSpec (django.contrib.admin.filterspecs) .
   Trida FilterSpec zapouzdruje logiku zobrazovani filtru v django-adminu, podrobnosti viz 1.5.


1.5 filterspecs.py (django.contrib.admin.filterspecs)
=====================================================

trida FilterSpec.
- metoda (staticka) register(test, factory) -- factory je trida dedici z FilterSpec.
  napr.: FilterSpec.register(lambda f: isinstance(f, models.DateField), DateFieldFilterSpec)

- metoda (staticka) create(field, request, params, model, model_admin, fieldPath=None) -- pro kazdy
  databazovy field vyzkousi udelat test vsech zaregistrovanych filtru. Pokud test vyjde,
  vrati instanci FilterSpec-potomka tridy zaregistrovane s testem a nepokracuje v hledani jineho vhodneho filtru.
  Z toho plyne, ze bychom nase vlastni filtry meli registrovat driv nez se zaregistruji ty vychozi.

- metoda has_output() -- vraci True/False

- metoda choices(ChangeList_instance) -- NotImplementedError() / pretizit v konkretnim filtru.
  Jeji vysledek se pouziva v metode output(), ktera se stara o vyrenderovani seznamu polozek filtru (Dle: vytvoreno atp.).
  Struktura navratovych dat:
  {
      'selected': True/False,
      'query_string': (%s__exact % field_path),
      'display': 'zena.centrum.cz'
  }   ...field_path je treba pro filtr podle site v clancich: 'category__site__id'.

- metoda title() -- vraci verbose_name db Fieldu, pro ktery je filter trida vytvorena.

- metoda output(ChangeList_instance) -- vyblije kus HTML kodu reprezentujiciho polozku filtru,
  resi take zvyrazneni uzivatelem vybraneho filtru. Pokud self.has_output() == False, tak vyplivne prazdny retezec.

tridy odvozene od FilterSpec realizuji ruzne filtry, napr.: DateFieldFilterSpec, BooleanFieldFilterSpec,
AllValuesFilterSpec -- "posledni zachrana", registruje se jako posledni v poradi.


1.6 templatetags/admin_list.py (django.contrib.admin.templatetags.admin_list)
=============================================================================

1. def items_for_result(ChangeList_instance, result) -- #&!@*, ktera vytvori change_list,
   tabulku se seznamem objektu, ktere se vypisou.

2. def results(ChangeList_instance) -- generator, ktery doluje data z ChangeList_instance.result_list

3. def result_headers(ChangeList_instance) -- hlavicka tabulky changelistu (generator).
   Projde vsechny polozky ChangeList_instance.list_display, je-li polozka nazvem Fieldu,
   prida do hlavicky jeho verbose_name.
   Je-li polozka __unicode__ nebo __str__, prida do hlavicky ChangeList_instance.lookup_opts.verbose_name .
   Je-li callable(polozka) == True, pak se pokusi ziskat hodnotu property polozka.short_description ,
   nezdari-li se, generuje (yield) hodnotu polozka.__name__ .
   Pokud neni polozka callable, snazi se o ziskani hodnoty property
   ChangeList_instance.model_admin.polozka.short_description , pokud short_description
   na polozce neexistuje, zavola aspon .__name__ .

4. date_hierarchy(ChangeList_instance) -- tam by se hodilo obratit tu podminku, at neni cela metoda telem jedineho ifu.





======================
2. Uzivatelska prava
======================


2.1 Uzivatelska prava
=====================

Stranka pojednavajici o pravech [http://docs.djangoproject.com/en/dev/topics/auth/#permissions] .

Uzivatelska prava lze pridelovat pouze na urovni modelu, tedy podle ContentTypu (uzivatel ma pravo
menit nebo mazat, zakladat Clanek).

Modul django.contrib.auth.backends obsahuje mmj. funkce pro zjistovani uzivatelskych prav
``get_group_permissions(user_obj)``, ``get_all_permissions(user_obj)``,
``has_perm(user_obj, perm)``, ``has_module_perms(user_obj, app_label)``.


__kazda metaclass Modelu__ ma metody ``get_add_permission()``,
``get_change_permission()`` a ``get_delete_permission()`` -- tyto vraci nazev opravneni.
Pote se pomoci '%s.%s' % ( app_label, mode._meta.get_add_permission() ) zjisti boolean
hodnota pro kazde ze tri uvedenych pristupovych prav.


1. Model uzivatelskych prav v django.contrib.auth.models -- trida Permission

2. Definovani vlastni prav  (per model):
   [http://docs.djangoproject.com/en/dev/topics/auth/#id1]

3. {{ perms }} promenna pritomna v sablone, pouziti napr.: {% if perm.nazev_modelu.has_opravneni %} jako test
   na prava operace "opravneni" na modelu "nazev_modelu"

4. Q: kombinuji se prava skupiny s pravy uzivatele? A: ...


==================
3. Shrnuti
==================

Uzivatelska prava: staci nam-li jen hlidat prava pro zakladani/modifikaci/mazani s rozlisenim na ContentType,
vyuzijeme stavajici mechanismy. Pripadne muzeme dopsat do django.contrib.auth.backends dalsi funkce,
ktere pouzijeme stejnym zpusobem jako jsou stavajici tj. pridame funkce do ``django.contrib.auth.models.User ``

Prava muzeme overovat i v sablonach (viz vyse, pripadne manual) skrz {{ perm }}.


Filtry: Podrobne v bodu 1.5. Filtry jsou potomci tridy FilterSpec. Registruji se pomoci staticke
metody FilterSpec.register( test_callback, FilterSpec_potomek )
Nase vlastni filtry bychom meli registrovat driv nez se zaregistruji vychozi. K registraci bohuzel
dochazi hned po definici ruznych vychozich filtrovacich trid primo v modulu, tedy
__navrhuji do FilterSpec pridat jeste jednu registracni funkci__, ktera umozni do listu filtru pridat
registraci na zacatek, nyni se pouze appenduji.

Adminovske tridy:
Urcite vyuzijeme pretizeni AdminSite.root() pro registraci vlastnich URL at uz pro AJAX nebo jine
veci jako je status memcached atp.
